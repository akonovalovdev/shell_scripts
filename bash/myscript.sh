#!/bin/bash
# Проверки файлов
-d fileПроверяет, существует ли файл, и является ли он директорией.
-e fileПроверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r fileПроверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w fileПроверяет, существует ли файл, и доступен ли он для записи.
-x fileПроверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G fileПроверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

#________________________________________________________________________
#Сравнение чисел
 #
 #В скриптах можно сравнивать числовые значения. Ниже приведён список соответствующих команд.
 #
 #n1 -eq n2Возвращает истинное значение, если n1 равно n2.
 #n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2.
 #n1 -gt n2Возвращает истинное значение, если n1 больше n2.
 #n1 -le n2Возвращает истинное значение, если n1меньше или равно n2.
 #n1 -lt n2Возвращает истинное значение, если n1 меньше n2.
 #n1 -ne n2Возвращает истинное значение, если n1не равно n2.
 # Пример
 # val1=6
   #if [ $val1 -gt 5 ]
   #then
   #echo "The test value $val1 is greater than 5"
   #else
   #echo "The test value $val1 is not greater than 5"
   #fi
# Сравнение строк
#str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
 #str1 != str2Возвращает истину, если строки не идентичны.
 #str1 < str2Возвращает истину, если str1меньше, чем str2.
 #str1 > str2 Возвращает истину, если str1больше, чем str2.
 #ператоры «>» и «<» необходимо экранировать с помощью обратной косой черты,
 # иначе скрипт будет работать неправильно, хотя сообщенийоб ошибках и не появится.
 # Скрипт интерпретирует знак «>» как команду перенаправления вывода
 #-n str1 Возвращает истину, если длина str1больше нуля.
 #-z str1Возвращает истину, если длина str1равна нулю.
 # Пример
   #user ="likegeeks"
   #if [$user = $USER]
   #then
   #echo "The user $user  is the current logged in user"
   #fi
#!/bin/bash
#val1=Likegeeks
#val2=likegeeks
#if [ $val1 \< $val2 ]
#then
#echo "$val1 is greater than $val2"
#else
#echo "$val1 is less than $val2"
#fi
# В командах сравнения прописные буквы меньше строчных. Сравнение
# строк здесь выполняется путём сравнения ASCII-кодов символов,
# порядок сортировки, таким образом, зависит от кодов символов
#_________________________________________________________________________
# Вложенные условия if-then-elif-then
#if команда1
 #then
 #команды
 #elif команда2
 #then
 #команды
 #fi
# можно, например, создавать нового пользователя с помощью команды useradd,
# если поиск не дал результатов, или делать ещё что-нибудь полезное.
#!/bin/bash
#user=anotherUser
#if grep $user /etc/passwd
#then
#echo "The user $user Exists"
#elif ls /home
#then
#echo "The user doesn’t exist but anyway there is a directory under /home"
#fi
#_________________________________________________________________________
# Управляющая конструкция if-then-else
#if команда
 #then
 #команды
 #else
 #команды
 #fi

# user=anotherUser
# if grep $user /etc/passwd
# then
# echo "The user $user Exists"
# else # исполнение пошло по ветке else.
# echo "The user $user doesn’t exist"
# fi

#________________________________________________________________________
# Управляющая конструкция if-then
# if команда
# then
# команды
# fi
# Рабочая версия
#if pwd
#then
#echo "It works"
#fi
# надо найти некоего пользователя в /etc/passwd,
# и если найти его удалось, сообщить о том, что он существует.
#user=likegeeks
#if grep $user /etc/passwd # нет такого пользователя, ничего не печатает
#then
#echo "The user $user Exists"
#fi
#___________________________________________________________________
# Для выполнения математических операций в файле скрипта можно
# использовать конструкцию вида $((a+b)):

#var1=$(( 5 + 5 ))
#echo $var1
#var2=$(( $var1 * 2 ))
#echo $var2

#______________________________________________________________________
# Одна из самых полезных возможностей bash-скриптов — это возможность
# извлекать информацию из вывода команд и назначать её переменным

# 2 способа: С помощью значка обратного апострофа ` `
#            С помощью конструкции $()
#mydir=`pwd`
#mydir1=$(pwd)
#echo $mydir; echo $mydir1


#_____________________________________________________________________________________
#This is a comment
#pwd
#whoami;pwd;whoami;pwd;whoami;pwd;whoami;pwd;whoami;pwd;whoami;pwd;whoami

#echo "The current directory is:"
#pwd
#echo "The user logged in is:"
#whoami
#_____________________________________________________________________________
#Переменные позволяют хранить в файле сценария информацию,
# например — результаты работы команд для использования
# их другими командами.
#
#Нет ничего плохого в исполнении отдельных команд
# без хранения результатов их работы, но возможности
# такого подхода весьма ограничены.
#
#Существуют два типа переменных,
#которые можно использовать в bash-скриптах:
#переменные среды и пользовательские переменные
#
#echo "Home for the current user is: $HOME" # переменная среды
## чтобы вывести значек доллара, передним ставим бэк слэш
#echo "I have \$1 in my pocket"
#
## testing variables
#grade=5
#person="Adam"
#echo "$person is a good boy, he is in grade $grade"
#________________________________________________________________